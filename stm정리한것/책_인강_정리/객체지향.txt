객체지향

책임의 이동 > 의존성 좀더 낮추고 변경/읽기 쉬운 코드로 바꿀 수 있음
ex) 영화관 객체에 모든것을 집어넣으면 의존성 높아지고 변경어려움
관객, 판매원 등등 객체를 따로 만들어서 관리하면 변경이 쉬워지고 의존성 낮아짐

자율도 높히면(클래스가 이것저것 건드릴 수 있는 정도??객체가 스스로 판단하고 행동)
결합도 높아져 의존적이게 됨.. 
trade - off 따져가면서 설계해야함

능동/자율적인 객체로 만들어버리면 편함(생물로 생각하자)

도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

public interface : 외부접근가능
implementation : 내부에서만 사용가능한 메서드

협력 : 객체들 사이에서 이뤄지는 상호작용

책임 : doing / knowing
책임과 협력 관계를 나열해서 객체지향 어떻게 설계할것인지 생각
후보(클래스명 정함?)-책임(doing)-협력(책임에 필요한 객체)

책임주도 설계 : 책임파악 > 책임 분할 > 책임 할당 > 협력
메시지를 전송할 객체를 무엇을 원하는가..
메시지를 수신할 적합한 객체는 누구인가를 생각하면서 책임 할당해줘야함

높은 응집도 낮은 결합도

상태보다는 객체의 행동을 중점으로 먼저 설계

인터페이스 : 변경 가능성 낮은것.. 안정화된거..

메서드 분해해서 각각 알맞는 함수 여러개 만들어서 사용..
이러면 변경해도 구조가 크게 바뀌지 않아 좋음

top down 방식은 변경에 취약함. 변경이 잘 안되는 경우에는 좋음

모듈화(책임 할당) > 가능한 적게 인터페이스 노출
변경 가능성 있는 것을 내부로 감추고 변경 가능성이 적은것을 인터페이스화 하는게 좋아

c언어는 소스 파일에 모듈 구현.. 필요시 extern 이용해서 노출함
cpp는 namespace 이용해서 모듈 구현

의존성 해결하기 : 컴파일 시간에 결정되는거 보단 런타임 시간에 결정되는게 좋아
1. 생성자 통해 해결
2. setter 메서드로 해결
3. 1,2 둘다 섞어서
근데 new 쓰는데 임베디드에서는 사용하는게 좋긴하려나...

